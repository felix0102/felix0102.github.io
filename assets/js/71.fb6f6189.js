(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{249:function(e,n,t){"use strict";t.r(n);var a=t(6),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"nginx-yum-install"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx-yum-install"}},[e._v("#")]),e._v(" nginx yum install")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://nginx.org/en/linux_packages.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("yum repo"),t("OutboundLink")],1)])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[nginx-stable]\nname=nginx stable repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=1\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n\n[nginx-mainline]\nname=nginx mainline repo\nbaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n")])])]),t("h2",{attrs:{id:"配置反向代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置反向代理"}},[e._v("#")]),e._v(" 配置反向代理")]),e._v(" "),t("h3",{attrs:{id:"配置反向代理例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置反向代理例子"}},[e._v("#")]),e._v(" 配置反向代理例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('server {\n        listen       80;\n        server_name  localhost;\n        location / {\n         rewrite ^/(.*) https://$host/$1 permanent;\n        }\n    }\n\n       server {\n        listen 443 ssl;\n        error_page  404 404.html;\n        server_name _;\n        ssl_certificate "/etc/nginx/server.crt";\n        ssl_certificate_key "/etc/nginx/server.key";\n        ssl_session_timeout 5m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\n        ssl_prefer_server_ciphers on;\n        location / {\n            proxy_set_header Host $host:$server_port;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass https://132.145.230.64;\n        }\n    }\n')])])]),t("h2",{attrs:{id:"配置gzip功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置gzip功能"}},[e._v("#")]),e._v(" 配置gzip功能")]),e._v(" "),t("h3",{attrs:{id:"gzip-打开例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gzip-打开例子"}},[e._v("#")]),e._v(" gzip 打开例子")]),e._v(" "),t("p",[e._v("ginx实现资源压缩的原理是通过ngx_http_gzip_module模块拦截请求，并对需要做gzip的类型做gzip，ngx_http_gzip_module是Nginx默认集成的，不需要重新编译，直接开启即可。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("gzip on;\ngzip_min_length  5k;\ngzip_buffers     4 16k;\n#gzip_http_version 1.0;\ngzip_comp_level 3;\ngzip_types       text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\ngzip_vary on;\n")])])]),t("h3",{attrs:{id:"配置指令详细注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置指令详细注释"}},[e._v("#")]),e._v(" 配置指令详细注释")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('gzip on|off\n# 默认值: gzip off\n# 开启或者关闭gzip模块\n\ngzip_static on|off\n\n# nginx对于静态文件的处理模块\n# 该模块可以读取预先压缩的gz文件，这样可以减少每次请求进行gzip压缩的CPU资源消耗。该模块启用后，nginx首先检查是否存在请求静态文件的gz结尾的文件，如果有则直接返回该gz文件内容。为了要兼容不支持gzip的浏览器，启用gzip_static模块就必须同时保留原始静态文件和gz文件。这样的话，在有大量静态文件的情况下，将会大大增加磁盘空间。我们可以利用nginx的反向代理功能实现只保留gz文件。\n# 可以google"nginx gzip_static"了解更多\n\ngzip_comp_level 4\n\n# 默认值：1(建议选择为4)\n# gzip压缩比/压缩级别，压缩级别 1-9，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。\n\ngzip_buffers 4 16k\n\n# 默认值: gzip_buffers 4 4k/8k\n# 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。\n# 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。\n\ngzip_types mime-type [mime-type ...]\n\n# 默认值: gzip_types text/html (默认不对js/css文件进行压缩)\n# 压缩类型，匹配MIME类型进行压缩\n# 不能用通配符 text/*\n# (无论是否指定)text/html默认已经压缩\n# 设置哪压缩种文本文件可参考 conf/mime.types\n\ngzip_min_length  1k\n\n# 默认值: 0 ，不管页面多大都压缩\n# 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。\n# 建议设置成大于1k的字节数，小于1k可能会越压越大。 即: gzip_min_length 1024\n\ngzip_http_version 1.0|1.1\n\n# 默认值: gzip_http_version 1.1(就是说对HTTP/1.1协议的请求才会进行gzip压缩)\n# 识别http的协议版本。由于早期的一些浏览器或者http客户端，可能不支持gzip自解压，用户就会看到乱码，所以做一些判断还是有必要的。\n# 注：99.99%的浏览器基本上都支持gzip解压了，所以可以不用设这个值,保持系统默认即可。\n# 假设我们使用的是默认值1.1，如果我们使用了proxy_pass进行反向代理，那么nginx和后端的upstream server之间是用HTTP/1.0协议通信的，如果我们使用nginx通过反向代理做Cache Server，而且前端的nginx没有开启gzip，同时，我们后端的nginx上没有设置gzip_http_version为1.0，那么Cache的url将不会进行gzip压缩\n\ngzip_proxied [off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any] ...\n\n# 默认值：off\n# Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含"Via"的 header头。\noff - 关闭所有的代理结果数据的压缩\nexpired - 启用压缩，如果header头中包含 "Expires" 头信息\nno-cache - 启用压缩，如果header头中包含 "Cache-Control:no-cache" 头信息\nno-store - 启用压缩，如果header头中包含 "Cache-Control:no-store" 头信息\nprivate - 启用压缩，如果header头中包含 "Cache-Control:private" 头信息\nno_last_modified - 启用压缩,如果header头中不包含 "Last-Modified" 头信息\nno_etag - 启用压缩 ,如果header头中不包含 "ETag" 头信息\nauth - 启用压缩 , 如果header头中包含 "Authorization" 头信息\nany - 无条件启用压缩\n\ngzip_vary on\n\n# 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\n\ngzip_disable "MSIE [1-6]."\n\n# 禁用IE6的gzip压缩，又是因为杯具的IE6。当然，IE6目前依然广泛的存在，所以这里你也可以设置为“MSIE [1-5].”\n# IE6的某些版本对gzip的压缩支持很不好，会造成页面的假死，今天产品的同学就测试出了这个问题\n后来调试后，发现是对img进行gzip后造成IE6的假死，把对img的gzip压缩去掉后就正常了\n为了确保其它的IE6版本不出问题，所以建议加上gzip_disable的设置\n')])])]),t("h2",{attrs:{id:"配置代理缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置代理缓存"}},[e._v("#")]),e._v(" 配置代理缓存")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('proxy_cache_path /cache levels=1:2 keys_zone=cache:10m max_size=10g inactive=60m use_temp_path=off;\n\nserver{\n\tlisten 80;\n\tserver_name proxya.com;\n\tlocation / {\n\t\tproxy_pass http://proxyb.com;\n\t}\n\tlocation ~ .*\\.(gif|jpg|png|css|js|svg)(.*)  {\n        proxy_pass http://proxyb.com;\n\t\tproxy_cache cache;\n    \tproxy_cache_valid   200 304 12h;\n    \tproxy_cache_valid   any 10m;\n    \tadd_header  Nginx-Cache "$upstream_cache_status";\n        add_header X-Cache-Status $upstream_cache_status;\n\t\tproxy_cache_key $host$uri$is_args$args;\n\t}\n}\n\n# proxy_cache_path 缓存文件存放位置\n# levels=1:2       代表缓存的目录结构为2级目录\n# keys_zone=cache:10m 申请一个10兆的空间存在缓存的key 名称为cache\n# max_size 最大存储缓存的空间10G\n# inactive 未被访问文件在缓存中保留时间，本配置中如果60分钟未被访问则不论状态是否为expired，缓存控制程序会删掉文件。inactive默认是10分钟。\n           需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件\n# use_temp_path 如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储。\n# proxy_cache cache;  启动名称为cache的缓存\n# proxy_cache_valid 200 302 10m; 只对响应码为200，301，302的访问请求资源设置缓存时间10m\nCan the NGINX Cache Be Instrumented?\nYes, with the add_header directive:\nadd_header X-Cache-Status $upstream_cache_status;\n')])])]),t("h2",{attrs:{id:"errors"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#errors"}},[e._v("#")]),e._v(" errors")]),e._v(" "),t("h3",{attrs:{id:"_13-permission-denied-while-connecting-to-upstream-nginx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-permission-denied-while-connecting-to-upstream-nginx"}},[e._v("#")]),e._v(" (13: Permission denied) while connecting to upstream:[nginx]")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("I had a similar issue getting Fedora 20, Nginx, Node.js, and Ghost (blog) to work. It turns out my issue was due to SELinux.\n\nThis should solve the problem:\n\nsetsebool -P httpd_can_network_connect 1\nDetails\nI checked for errors in the SELinux logs:\n\nsudo cat /var/log/audit/audit.log | grep nginx | grep denied\nAnd found that running the following commands fixed my issue:\n\nsudo cat /var/log/audit/audit.log | grep nginx | grep denied | audit2allow -M mynginx\nsudo semodule -i mynginx.pp\n")])])]),t("h2",{attrs:{id:"reqeust-time"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reqeust-time"}},[e._v("#")]),e._v(" Reqeust time")]),e._v(" "),t("ul",[t("li",[e._v("https://blog.csdn.net/yangyangye/article/details/105819628")])]),e._v(" "),t("h2",{attrs:{id:"reference-link"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference-link"}},[e._v("#")]),e._v(" Reference Link")]),e._v(" "),t("ul",[t("li",[e._v("https://blog.csdn.net/Michaelwubo/article/details/81865756")]),e._v(" "),t("li",[e._v("https://www.nginx.com/blog/nginx-caching-guide/")]),e._v(" "),t("li",[e._v("http://nginx.org/en/docs/")])])])}),[],!1,null,null,null);n.default=s.exports}}]);